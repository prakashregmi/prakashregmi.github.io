name: ðŸš€ Dynamic Release Creator

# 1. Workflow Trigger: Manual dispatch allows user to select version type
on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Type of version bump (minor or patch)'
        required: true
        default: 'minor'
        type: choice
        options:
          - minor # 1.1.0 -> 1.2.0
          - patch # 1.1.0 -> 1.1.1

jobs:
  create_release:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to create the tag and release

    steps:
      - name: Checkout code (fetch all tags)
        uses: actions/checkout@v4
        with:
          # Fetch full history including tags to determine the latest version
          fetch-depth: 0

      # 2. Logic: Find the latest tag and calculate the next version
      - name: Calculate Next Version
        id: calculate_version
        run: |
          # Find the latest tag. If no tags exist, default to 0.0.0.
          # The 2>/dev/null suppresses errors if no tags are found.
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          echo "Last Tag Found: $LATEST_TAG"

          # Use sed to strip any leading 'v' (case-insensitive) and tr to replace dots with spaces
          VERSION_NUMBERS=$(echo $LATEST_TAG | sed 's/^v//I' | tr '.' ' ')
          
          # Use awk to split the version string into MAJOR, MINOR, PATCH
          MAJOR=$(echo $VERSION_NUMBERS | awk '{print $1}' || echo "0")
          MINOR=$(echo $VERSION_NUMBERS | awk '{print $2}' || echo "0")
          PATCH=$(echo $VERSION_NUMBERS | awk '{print $3}' || echo "0")

          # Default to 0 if parsing fails
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          NEXT_TAG=""

          if [ "$VERSION_TYPE" == "minor" ]; then
            # Bump Minor: M.m.p -> M.(m+1).0
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
            NEXT_TAG="$MAJOR.$NEW_MINOR.$NEW_PATCH"
          elif [ "$VERSION_TYPE" == "patch" ]; then
            # Bump Patch: M.m.p -> M.m.(p+1)
            NEW_PATCH=$((PATCH + 1))
            NEXT_TAG="$MAJOR.$MINOR.$NEW_PATCH"
          else
            echo "::error::Invalid version_type specified: $VERSION_TYPE. Must be 'minor' or 'patch'."
            exit 1
          fi

          echo "Next Tag Calculated: $NEXT_TAG"
          
          # Set the calculated tag as an output variable for the next step
          echo "next_tag=$NEXT_TAG" >> $GITHUB_OUTPUT
          # Also export the latest tag found for the changelog step
          echo "last_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      # 3. New Step: Generate Changelog and Get SHA (UPDATED)
      - name: Generate Changelog and Get SHA
        id: changelog
        run: |
          LAST_TAG="${{ steps.calculate_version.outputs.last_tag }}"
          
          # Get the first 8 characters of the current commit SHA
          CURRENT_SHA_SHORT=$(echo $GITHUB_SHA | cut -c 1-8)
          echo "short_sha=$CURRENT_SHA_SHORT" >> $GITHUB_OUTPUT # Export SHA
          
          echo "Generating log from tag: $LAST_TAG"

          # Log range setup
          if [ "$LAST_TAG" == "0.0.0" ]; then
            LOG_RANGE=""
          else
            # Log commits between the last tag and HEAD. We keep merge commits in case they contain PR info.
            LOG_RANGE="$LAST_TAG..HEAD"
          fi

          # Log format: Subject|AuthorName
          LOG_OUTPUT=$(git log --pretty=format:'%s|%an' $LOG_RANGE)

          CHANGELOG=""
          # Process the log output line by line
          while IFS='|' read -r SUBJECT AUTHOR
          do
            # Check if the SUBJECT ends with a PR number pattern: "Title (#PR_NUMBER)"
            # BASH_REMATCH[1] will capture the Title
            # BASH_REMATCH[2] will capture the PR_NUMBER
            if [[ "$SUBJECT" =~ ^(.*)\s\(\#([0-9]+)\)$ ]]; then
              TITLE="${BASH_REMATCH[1]}"
              PR_NUMBER="${BASH_REMATCH[2]}"
              
              # Construct the PR link using GitHub environment variables
              PR_URL="$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/pull/${PR_NUMBER}"
              
              # Format: * Clean Title ([#PR_NUMBER](PR_URL)) (by @author)
              LINE="* ${TITLE} ([#${PR_NUMBER}](${PR_URL})) (by @${AUTHOR})"
            else
              # Fallback for commits without a PR number (e.g., initial commit, direct push)
              # Format: * Subject (by @author)
              LINE="* ${SUBJECT} (by @${AUTHOR})"
            fi
            
            # Append the line to the changelog with a newline
            CHANGELOG="${CHANGELOG}${LINE}\n"
          done <<< "$LOG_OUTPUT"

          # Use sed to remove any blank lines (e.g., if LOG_OUTPUT was empty)
          CHANGELOG=$(echo -e "$CHANGELOG" | sed '/^$/d')

          # Export the final formatted changelog
          echo "changelog<<EOF_CHANGELOG" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF_CHANGELOG" >> $GITHUB_OUTPUT

      # 4. Action: Create the new Git Tag and GitHub Release
      - name: Create GitHub Release and Tag
        uses: softprops/action-gh-release@v2
        # Only run if the tag calculation was successful
        if: steps.calculate_version.outputs.next_tag != ''
        env:
          # GITHUB_TOKEN is automatically provided by GitHub Actions
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.calculate_version.outputs.next_tag }}
          # Release name now includes the short commit hash
          name: Release ${{ steps.calculate_version.outputs.next_tag }} (${{ steps.changelog.outputs.short_sha }})
          body: |
            ## Release Details
            
            Commit SHA: `${{ steps.changelog.outputs.short_sha }}`
            
            This release was automatically generated with a **${{ github.event.inputs.version_type }}** version bump.
            
            Based on previous tag: `${{ steps.calculate_version.outputs.last_tag }}`
            
            ---
            
            ## Changelog
            
            ${{ steps.changelog.outputs.changelog }}
            
          draft: false
          prerelease: false

      # 5. New Step: Force Tag ci/prod to the released commit
      - name: Force Tag ci/prod and Push
        # We need the GITHUB_TOKEN to perform the forced push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Configuring git identity..."
          # Configure git identity for the push
          git config user.name github-actions[bot]
          git config user.email github-actions[bot]@users.noreply.github.com
          
          echo "Force-creating ci/prod tag on current commit..."
          # Force create/move the ci/prod tag to the current commit
          git tag -f ci/prod
          
          echo "Force-pushing ci/prod tag to origin..."
          # Force push the ci/prod tag to the remote
          git push origin ci/prod -f
